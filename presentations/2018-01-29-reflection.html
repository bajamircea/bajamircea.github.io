---
layout: presentation
title: Boilerplate, metaprogramming, reflection in C++
---

Mircea Baja @ ACCU Oxford - 29th January 2018

# Boilerplate, metaprogramming, reflection in C++

---
class: large-points

# Executive summary

- We need better reflective metaprogramming facilities in C++
- There are proposals to address it
- It's a complex issue
- Standardisation will likely happen after 2020


--

- If you think 2020 is far, spare a though for the pioneers that dreamt it late
  90s, early 2000.

---

# Sample problem

---

background-image: url(../assets/2018-01-29-reflection/labrador.jpg)

---

# Data

```json
{
  "name": "Kipper",
  "breed": "Labrador"
}
```

---

# Traditional bad C++ solution

```cpp
class bad_dog
{
private:
  std::shared_ptr<std::string> name_;
  std::shared_ptr<std::string> breed_;

public:
  std::shared_ptr<std::string> get_name();
  void set_name(std::shared_ptr<std::string> value);

  std::shared_ptr<std::string> get_breed();
  void set_breed(std::shared_ptr<std::string> value);

  void init(const Json & doc);
};
```
---
class: large-points

# Issues with this traditional solution

- reference semantings leading to
- difficulty of local reasoning and
- complex memory layout leading to
- degraded performance
- getter and setters leading to
- combinatoric interface
- init method leading to
- multi-step initialization
- multiple responsabilities leading to
- maintenability and
- testing dificulties

---

# Bad memory layout

![Image](../assets/2018-01-29-reflection/bad_dog.png)

---

# Better C++ solution

```cpp
struct dog
{
  std::string name;
  std::string breed;
};


dog dog_from_json(const Json & doc);
```

--

Physical layout:
- dog struct is defined in dog.h
- and serialization in dog_from_json.h and cpp.


---

# Memory layout

![Image](../assets/2018-01-29-reflection/dog.png)


---

# Boilerplate

---

# Deserialization

```cpp
dog dog_from_json(const Json & doc)
{
  dog x;

  x.name = doc['name'].as_string();
  x.breed = doc['breed'].as_string();

  return x;
}
```
--
```cpp
dog dog_from_json(const Json & doc)
{
  return {
    doc['name'].as_string(),
    doc['breed'].as_string()
  };
}
```

---

# Equality

```cpp
bool operator==(const dog & left, const dog & right) noexcept
{
  if (left.name != right.name)
  {
    return false;
  }
  return left.breed == right.breed;
}
```
--
```cpp
bool operator==(const dog & left, const dog & right) noexcept
{
  return (left.name == right.name) &&
    (left.breed == right.breed);
}
```

---

# Order

```cpp
bool operator<(const dog & left, const dog & right) noexcept
{
  if (left.name < right.name)
  {
    return true;
  }
  if (left.name > right.name)
  {
    return false;
  }
  return left.breed < right.breed;
}
```
--
```cpp
bool operator<(const dog & left, const dog & right) noexcept
{
  if (left.name != right.name)
  {
    return left.name < right.name;
  }
  return left.breed < right.breed;
}
```

---

# Other comparison operators

```cpp
bool operator!=(const dog & left, const dog & right) noexcept
{
  return !(left == right);
}

bool operator<=(const dog & left, const dog & right) noexcept
{
  return !(right < left);
}

bool operator>(const dog & left, const dog & right) noexcept
{
  return right < left;
}

bool operator>=(const dog & left, const dog & right) noexcept
{
  return !(left < right);
}
```

---

# Metaprogramming currently

---

# Tie members alternative

```cpp
auto tie_members(const dog & x) noexcept
{
  return std::tie(x.name, x.breed);
}
// returns a std::tuple<std::string &, std::string &>
```

--
```cpp
bool operator==(const dog & left, const dog & right) noexcept
{
  return tie_members(left) == tie_members(right);
}

bool operator<(const dog & left, const dog & right) noexcept
{
  return tie_members(left) < tie_members(right);
}

// etc.
```

---

# Tie with (some) check

```cpp
template<class T, typename ... Args>
auto tie_with_check(Args & ... args) noexcept
{
  static_assert(sizeof(T) == sizeof(std::tuple<Args...>),
    "You forgot a member variable");
  return std::tie(args...);
}
```
--
```cpp
auto tie_members(const dog & x) noexcept
{
  return tie_with_check<dog>(x.name, x.breed);
}
```

--

'tuple' is usually implemented using recursive derivation, not as side by
side member declaration as a struct.

Therefore there is no guarantee that std::tuple has the same layout as the struct.

Padding might be different.

---

# Tuple inheritance

![Image](../assets/2018-01-29-reflection/tuple_inheritance.png)

---

# Padding

![Image](../assets/2018-01-29-reflection/padding.png)

---

# Historical side note

The padding is the historical reason why the compiler does not automatically
generate order operators in C (and inherited in C++).

Copy was implemented as memcopy and comparing using memcmp was not right given the padding.

Instead of memberwise comparing we got no automatically generated comparison.

(source Alex Stepanov)

---

# Struct layout

```cpp
template<typename ... Args>
struct struct_layout;

template<typename T0>
struct struct_layout<T0>
{
  T0 m0;
};

template<typename T0, typename T1>
struct struct_layout<T0, T1>
{
  T0 m0; T1 m1;
};

// and so on up to the max number of members you support
```
--
```cpp
  static_assert(sizeof(T) == sizeof(struct_layout<Args...>),
    "You forgot a member variable");
```
---
class: large-points

# Issues with current metaprogramming in C++

- it looks clever, but it is convoluted
- relies on the historical accident that the templates machinery is Turing
  complete


- conditionals ('if') use oveloading/template specialization
- iterations ('for') use use recursion (e.g. recursive inheritance)
- store state as parametrized types and constants
- instantiate template to trigger the computation

---
class: large-points

# Issues with current reflection support in C++

- is very limited, relies on overloading, template specialization, concepts


- can query for types e.g. std::is_pointer
- can do simple type transformations e.g. std::make_unsigned


- can't enumerate members
- can't get names

---

# Reflective metaprogramming

Facilities to generate code based on existing code

---
class: large-points

# Use case: common operators

- ==, < implemented lexicographically
- implement !=, <=, >= etc. in terms of the above
- std::hash


- problems:
- can you do all in one go or piecemeal?
- hash might be in a different namespace (the need to specify where code
  generation takes place)
- some functions are, some function are not members of the class

---
class: large-points

# Use case: serialization

- to/from JSON/XML
- relational database mapping
- logging function arguments
- ASSERT_EQ macro in tests


- problems:
- getting names of the parent context
- getting the current function as input for reflection

---

# Use case: enum to/from string

```cpp
enum class foo_bar{ foo, bar };
auto to_string(foo_bar x) noexcept
{
  switch (x)
  {
  case foo_bar::foo: return "foo";
  case foo_bar::bar: return "bar";
  default: std::terminate();
  }
}
```

---
class: large-points

# Use case: transformation

- C structure mapping a C++ structure members
- mock class for a interface
- member functions wrapping (e.g. with logging, locking, pimpl)
- stand alone function wrapping (e.g. variations of error handling)


- problems:
- which file (even language) is the code generated in
- dealing with templates (class or function)

---
class: large-points

# Use case: identifiers on the fly

- currently they require macros

---
class: large-points

# Reflection workflow

![Image](../assets/2018-01-29-reflection/reflection_workflow.png)

???

- reflect on a source construct
- analyse
- generate something to execute

---

# Static vs dynamic reflection

A lot of languages support dynamic reflection:

- reflection/generation not at compile time
- not a zero-cost abstraction, it forbits optimisations of original source code constructs.
- generation could mean "function invocation" at runtime


For C++ we want static reflection metaprogramming

---

# Static reflection

![Image](../assets/2018-01-29-reflection/static_reflection.png)

???

- based on a source construct
- the reflection operator retuns a description of the source construct
- code generation is based on a description of the source construct
- it all happens at compile time


---

# Domains and operators

![Image](../assets/2018-01-29-reflection/operator_domains.png)

---

Encoding reflection values:
- as types: values have different types
- as objects: values have same type

---

for...
(heterogenous constexpr for loop)

dealing with strings at compile time

---

- introspection

---
reflexpr
P0194R3 - 
also P0578R0 
@ 
Jackie Kay: Practical (?) Applications of Reflection @ C++Now 2017
https://www.youtube.com/watch?v=JrOJ012XxNg


operator$/cpp3k
P0590R0

P0633R0
---
Andrew Sutton's references:

P0194, P0385 by Matus Chochlik, Axel Naumann, David Sankel
Type-based reflection with template metaprogramming

- uses 'reflexpr' as the reflection operator
- yields a new type describing the source construct
- properties are static members of the class
- projection operators are type traits or 'unreflexpr' for more complex cases

Advantages:
- powerful
- few compiler intrinsics

Disadvantages:
- but has downside of using templates machinery to perform
  computation
- a lot of classes generated: low compile-time performance

---

P0590, P0589, P0712 by Andrew Sutton, Herb Sutter
Type-based reflection with heterogenous containers

- uses $ as the reflection operator
- $ applies to: variables, types, namespaces
- the return type depends on what was reflected on (it's a template
  specialization, but you would use auto all the time anyway)
- properties are static constexpr members
- projection operators as 'typename', 'namespace', 'idexpr'

- requires more compiler intrinsics
- because they are template specialization properties are not instantiated
  until called (sometimes good, sometimes bad)
- getting class members returns a heterogenous tuple-like container

- 'idexpr' useful when you build ids.

P0633 by Daveed Vandevoorde, Louis Dionne
Additional ideas

---

Heterogenous loop

aka. unrolled loop, loop expansion

for... (auto x : $s.member_variables())
{
  std::cout << x.name();
}

expands to

auto && tup = $s.member_variables();
{ auto x = std::get<0>(tup); cout << x.name(); }
{ auto x = std::get<1>(tup); cout << x.name(); }

---

Ongoing work: using values to encode reflection

---

# References

CppCon 2017: Andrew Sutton "Reflection"

https://www.youtube.com/watch?v=N2G-Frv1z5Q


---

# Questions?

https://bajamircea.github.io/presentations/2018-01-29-reflection.html

