---
layout: presentation
title: Irregularity
---

Mircea Baja @ ACCU Oxford - 26 Feb 2020

# Irregularity in generic programming

???

The original idea of this talk is that diversity in data structures and
algorithms results in generic solutions being quirky and not universal (the
irregularity conjecture).

To get there, we're going to have a bit of fun with simple data structures
(linked lists) and simple algorithms (linear find and partition), see what
(C++20) concepts are, to build towards the more philosophical part
on the design and usage of generic code.

---
class: large-points

# Objective

- What is irregularity?
- What is regularity?
- The naming quirks
- Concepts (C++ 20)
- The irregularity continuum
- The irregularity conjecture
- A list/vector is just a kind of list/vector

---
class: large-points

# The vector theorem

- Theorem: `std::vector` is just a kind of vector (approx. quote of Alex Stepanov)

--
- Lemma: `std::list` is just a kind of linked list
- However, if you can only remember one thing: you shall use a `std::vector` by
  default (i.e. a memory contiguous data/extent based structure, the linked
  lists are for rare special situations)

--
- Many choices for linked lists, not all independent (orthogonal)

---

# Single linked

![Image](../assets/2018-06-23-linked-lists-options/01-single-linked.png)

--

# Double linked

![Image](../assets/2018-06-23-linked-lists-options/02-double-linked.png)

---

# Linear

![Image](../assets/2018-06-23-linked-lists-options/03-linear.png)

--

# Circular

![Image](../assets/2018-06-23-linked-lists-options/04-circular.png)

---

# Header - minimalistic

- pointer to head

![Image](../assets/2018-06-23-linked-lists-options/05-header-head.png)

- pointer to tail

![Image](../assets/2018-06-23-linked-lists-options/06-header-tail.png)

--

- or not minimalistic

---
class: large-points

# Iterators - minimalistic

--

# List size

--
# Splicing

- partial
- total

--

# Operations available

- e.g. constant time `push_back()`

---

# Links to local parts

- no

![Image](../assets/2018-06-23-linked-lists-options/07-no-links-to-local.png)

- yes

![Image](../assets/2018-06-23-linked-lists-options/08-links-to-local.png)

---

# Dummy node

![Image](../assets/2018-06-23-linked-lists-options/09-dummy-node.png)

- meaning (end iterator, none/simplify empty list case)
- location (heap, header)
- if on the heap: always present?
- can dereference/does it have a value?

---
class: large-points

# More

- Permanent end iterator
- Forward/Bidirectional iterator
- Intrusive/non-intrusive
- Iterator from reference to value
- Node ownership
- Allocators
- Meaning of node pointers
- Thread safety

---

# Single linked basic

![Image](../assets/2018-06-28-linked-lists-examples/01-single-basic.png)

- no constant time `push_back()`
- `std::forward_list`

---

# Single linked circular

![Image](../assets/2018-06-28-linked-lists-examples/02-single-circular.png)

- two choices on accessing tail from the iterator:
  - directly: as above
  - indirectly: through the header

---

# Single linked first-last

![Image](../assets/2018-06-28-linked-lists-examples/03-single-first-last.png)

---
class: large-points

# Single linked summary

- the price to pay for constant time `push_back()` either: iterator not
  minimalistic OR header not minimalistic

---

# Double linked linear

![Image](../assets/2018-06-28-linked-lists-examples/04-double-linear.png)

---

# Double linked circular

![Image](../assets/2018-06-28-linked-lists-examples/05-double-circular.png)

---

# Double linked with allocated dummy node

![Image](../assets/2018-06-28-linked-lists-examples/06-double-dummy-node.png)

- `std::list` in Visual C++ 2017

---

# Allocated dummy node

![Image](../assets/2018-06-28-linked-lists-examples/07-double-dummy-node.png)

--

```cpp
static_assert(std::is_nothrow_default_constructible_v<std::list<int>>,
  "Default constructor may throw");

static_assert(std::is_nothrow_move_constructible_v<std::list<int>>,
  "Move constructor may throw");

// both assert in Visual Studio C++ 2017
```

---

# Double linked with dummy node in header

![Image](../assets/2018-06-28-linked-lists-examples/08-double-dummy-in-header.png)

- `move` invalidates end

---
class: large-points

# Double linked summary

- does this remind you of Bubba from the Forest Gump film talking about shrimp?

---

# Implementing one

```cpp
template<typename T>
class dl_list {
  struct node;
  struct links {
    node * next_;
    node * prev_;
  };
  struct node : public links {
    T value_;
    //...
```

- a double linked list
- circular
- with dummy node in the header
- non-intrusive (nodes are provided by the list class)
- nodes are allocated on the heap (no custom allocator)
- list owns the nodes
- no cached size

---
class: large-points

# The naming quirks

- a lot of info is required to provide a complete description
- a pragmatic solution: reduced vocabulary
- `std::list` and `std::forward_list`
- `std::shared_ptr` and `std::unique_ptr`

---

# Incidental linear find

- find and replace the first `5` with `42`

```cpp
int data[] = {2, 5, 7, 1, 22};

for(int i = 0; i < 6; ++i);
{
  if (data[i] == 5) {
    // found
    data[i] = 42;
    return;
  }
}
// not found
```

--
- this was a trick question, code above is wrong

---

# Iterators: generalized pointers

- points to/hardware view

![Image](../assets/2020-02-26-irregularity/05-iterator-hardware.png)

- points between/Sean Parent view

![Image](../assets/2020-02-26-irregularity/06-iterator-sp.png)


---

# Linear find with pointers

```cpp
int * find(int * f, int * l, int x) {
  while ((f != l) && (*f != x)) ++f;
  return f;
}
```

```cpp
int data[] = {2, 5, 7, 1, 22};

int * it = find(std::begin(data), std::end(data), 5);
if (it != l) {
  // found
  *it = 42;
}
else {
  // not found
}
```

- note we compare f with l twice

---

# Linear find template - toy

```cpp
template<typename It, typename T>
It find(It f, It l, T x) {
  while ((f != l) && (*f != x)) ++f;
  return f;
}
```

- toy example, `x` is (sometimes) copied

---
class: large-points

# Requirements syntactic

- we can compare for equality `f` and `l`
- we can dereference `f`
- the iterator type has an associated value type
- dereferencing `f` is reference to the value type
- we can advance `f` (with `++`)

---
class: large-points

# Requirements semantic

- we can reach `l` from `f`
- once `f` equals `l`, it stays that way, we can compare again and get the same
  result
- and that's true even for a copy of `f`

---

# Linear find using concepts

```cpp
template<typename It>
using ValueType = typename It::value_type;

template<typename It>
concept InputIterator = requires(It a, It b)
{
    {a == b} -> std::boolean;
    {a != b} -> std::boolean;
    typename ValueType<It>;
    {*a} -> std::common_reference_with<ValueType<It>>;
    ++a;
};

template<typename It>
  requires InputIterator<It>
It find(It f, It l, const ValueType<It> & x)
{
    while ((f != l) && (*f != x)) ++f;
    return f;
}
```

- still toy example

---

# Linear find - industrial version

```cpp
template<InputIterator I, Sentinel<I> S, class T, class Proj = ranges::identity >
  requires IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
I find(I f, S l, const T& x, Proj proj = Proj{})
{
  while ((f != l) && (ranges::invoke(proj, *f) != x)) ++f;
  return f;
}
```

---

- non-intuitive synthetic names e.g. iterator

Irregularity is the property of generic data structures and algorithms of being
quirky and avoiding universality. 

- Regularity is a fundamental concept
- In practice, various degrees of regularity

Diversity in data structures and algorithms and consequences for generic
solutions: the irregularity continuum and the irregularity conjecture (that
generic solutions are quirky and escape universality)



---
---

# Books


<table>
<tr>
<td><img src="../assets/2020-02-26-irregularity/01-euclid.jpg" style="width: 100%" /></td>
<td><img src="../assets/2020-02-26-irregularity/02-goedel.jpg" style="width: 100%" /></td>
<td><img src="../assets/2020-02-26-irregularity/03-eop.jpg" style="width: 100%" /></td>
<td><img src="../assets/2020-02-26-irregularity/04-tarjan.jpg" style="width: 100%" /></td>
</tr>
</table>

---

# References


Alexander A. Stepanov and Paul McJones: Elements of Programming

Robert Endre Tarjan: Data Structures and Network Algorithms

# Links

https://bajamircea.github.io/coding/cpp/2018/08/01/linear-find.html

https://bajamircea.github.io/coding/cpp/2018/08/05/partition.html

https://bajamircea.github.io/coding/cpp/2018/06/28/linked-lists-examples.html

https://bajamircea.github.io/coding/cpp/2018/06/30/lists-implementing.html

https://bajamircea.github.io/presentations/2020-02-26-irregularity.html

---

# Thanks

Thanks go to Nigel Lester for organizing the ACCU meeting

---

# Questions?

